/*
设f(G,L)为有G次机会，L点生命值时最多可猜到 多少个数字 （注意此处的描述
猜数字我们都知道是要用二分法来猜. 首先，要考察G与L间的大小关系：
1）、若L=0，即一次都不可以猜高了，那么保险能猜到的方案就只有1、2、3、4...的一个一个往上猜，那么最多能猜到的数字个数也就是G
2）、若L>=G，即可以猜高的次数比较多。多出来的生命值也就没什么意义了，所以这种情况与L=G相同，即f(G ,G)
3）、若L<G，那么，就要继续分类考虑。首先进行一次猜测（假设猜的是k），那么可能得到以下三种情况之一：
（1）：猜低了。那么接下来的猜测就要相对于k往前,此时剩余G-1点机会，L点生命，也就是说可以再向前猜出f(G-1,L)个数字。
（2）：猜高了。也就是说正确答案小于k，那么接下来就要相对于k向后猜，同理，可以再向后猜出f(G-1,L-1）个数字。
（3）：恰好猜到～
总结下，即当L<=G时，f(G,L)=f(G-1,L)+f(G-1,L-1)+1
*/
#include<iostream>
#include<string.h>
using namespace std;
int opt[36][36];
int dp(int i, int j)
{
	//如果G为0的话，那么就没有机会才了
	if (i == 0) return 0;
	//如果L为0的话，那么就只能从低到高猜测
	if (j == 0) return i;
	//如果已经计算过了，那么就直接打开就好了
	if (opt[i][j]>0) return opt[i][j];
	//要是没有计算过的话，那么就需要现在计算
	opt[i][j] = dp(i - 1, j - 1) + dp(i - 1, j) + 1;
	//保存并且返回
	return opt[i][j];
}
int main()
{
	int g, l,cas=1;
	while (cin >> g >> l)
	{
		if (g + l == 0) break;
		if (l == 0){
			//没有猜高的机会，那么就只能从低到高猜测了
			cout << "Case " << cas++ << ": " << g << endl;
			continue;
		}
		if (l >= g) l = g;
		cout << "Case " << cas++ << ": " << dp(g,l)<< endl;
	}
	return 0;
}